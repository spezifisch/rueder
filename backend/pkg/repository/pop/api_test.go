package pop

import (
	"testing"
	"time"

	"github.com/cockroachdb/copyist"
	"github.com/gobuffalo/pop/v6"
	"github.com/gofrs/uuid"
	"github.com/spezifisch/rueder3/backend/pkg/api/controller"
	"github.com/spezifisch/rueder3/backend/pkg/helpers"
	"github.com/spezifisch/rueder3/backend/pkg/repository/pop/models"
	"github.com/stretchr/testify/assert"
)

func init() {
	// register copyist_postgres driver
	// pop is configured to use it in our included database.yml
	copyist.Register("postgres")

	fakeNow, _ := time.Parse(time.RFC3339, "2022-01-31T00:00:00Z")
	pop.SetNowFunc(func() time.Time { return fakeNow })
}

func TestSetup(t *testing.T) {
	configPath := "../../../config"
	migrationPath := "../../../migrations"

	_ = pop.AddLookupPaths(configPath)
	closer := copyist.Open(t)
	defer closer.Close()

	conn, err := pop.Connect("test")
	assert.NoError(t, err)

	if !copyist.IsRecording() {
		return
	}

	// recreate db
	_ = pop.DropDB(conn) // we don't care whether it exists
	err = pop.CreateDB(conn)
	assert.NoError(t, err)

	// create tables
	mig, err := pop.NewFileMigrator(migrationPath, conn)
	assert.NoError(t, err)
	err = mig.Up()
	assert.NoError(t, err)
}

func createUser(t *testing.T, pop *pop.Connection, userID uuid.UUID) {
	u := &models.User{
		ID: userID,
	}
	err := pop.Create(u)
	assert.NoError(t, err)
}

func TestAPIPopRepository_ChangeFolders(t *testing.T) {
	defer copyist.Open(t).Close()

	// this connection is reused between tests in this test table
	testPop, err := pop.Connect("test")
	assert.NoError(t, err)

	// good claims
	mockClaims := helpers.AuthClaims{
		// generated by a fair dice roll
		ID:         uuid.FromStringOrNil("6ff0b898-e79a-48f8-bc14-4bb48018360f"),
		Origin:     "somewhere",
		Name:       "someone",
		OriginName: "somewhere:someone",
	}
	createUser(t, testPop, mockClaims.ID)

	// some bad claims
	badClaims1 := mockClaims
	badClaims1.Name = ""

	badClaims2 := mockClaims
	badClaims2.Origin = ""
	badClaims2.Name = ""
	badClaims2.OriginName = ":"

	type fields struct {
		pop *pop.Connection
	}
	type args struct {
		claims  *helpers.AuthClaims
		folders []controller.Folder
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		{
			name: "folders nil",
			args: args{
				claims:  &mockClaims,
				folders: nil,
			},
			wantErr: true,
		},
		{
			name: "claims nil",
			args: args{
				claims:  nil,
				folders: []controller.Folder{},
			},
			wantErr: true,
		},
		{
			name: "bad claims 1",
			args: args{
				claims:  &badClaims1,
				folders: []controller.Folder{},
			},
			wantErr: true,
		},
		{
			name: "bad claims 2",
			args: args{
				claims:  &badClaims2,
				folders: []controller.Folder{},
			},
			wantErr: true,
		},
		{
			name: "folders empty",
			fields: fields{
				pop: testPop,
			},
			args: args{
				claims:  &mockClaims,
				folders: []controller.Folder{},
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			a := &APIPopRepository{
				pop: tt.fields.pop,
			}
			if err := a.ChangeFolders(tt.args.claims, tt.args.folders); (err != nil) != tt.wantErr {
				t.Errorf("ChangeFolders() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}
